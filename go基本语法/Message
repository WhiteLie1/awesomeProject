Go语言是静态类型语言，因此变量（variable）是有明确类型的。编译器会检查函数调用中，变量类型的正确性。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。

声明变量的一般形式是使用 var 关键字：
var identifier type 。

Go语言的基本类型有：
bool
string
int、int8、int16、int32、int64
uint、uint8、uint16、uint32、uint64、uintptr
byte // uint8 的别名
rune // int32 的别名 代表一个 Unicode 码
float32、float64
complex64、complex128

当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。
标准格式
Go 语言的变量声明的标准格式为：
var 变量名 变量类型

变量声明以关键字 var 开头，后置变量类型，行尾无须分号。
批量格式
觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法：
var (
    a int
    b string
    c []float32
    d func() bool
    e struct {
        x int
    }
)
使用关键字var和括号，可以将一组变量定义放在一起。
简短格式
除 var 关键字外，还可使用更加简短的变量定义和初始化语法。
名字 := 表达式

需要注意的是，简短模式（short variable declaration）有以下限制：
定义变量，同时显式初始化。
不能提供数据类型。
只能用在函数内部。

和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：
i, j := 0, 1

下面通过一段代码来演示简短格式变量声明的基本样式。
func main() {
   x:=100
   a,s:=1, "abc"
}
因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。

匿名变量的特点是一个下画线“_”，“_”本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个这个标识符作为变量对其它变量的进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：
纯文本复制
func GetData() (int, int) {
    return 100, 200
}
a, _ := GetData()
_, b := GetData()
fmt.Println(a, b)

go语言的作用域：

当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局的作用域查找。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：
在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是 if 或 for 等控制流语句构造的。下面的代码有三个不同的变量 x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。

Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。本节我们主要介绍一下整数类型。
Go语言同时提供了有符号和无符号类型的整数运算。其中包括 int8、int16、int32 和 int64 四种截然不同大小的有符号整数类型，分别对应 8、16、32、64bit 大小的有符号整数，与此对应的是 uint8、uint16、uint32 和 uint64 四种无符号整数类型。
Go语言提供了两种精度的浮点数，float32 和 float64。它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持。
这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在 math 包找到。常量 math.MaxFloat32 表示 float32 能表示的最大数值，大约是 3.4e38；对应的 math.MaxFloat64 常量大约是 1.8e308。它们分别能表示的最小值近似为 1.4e-45 和 4.9e-324。

内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部：
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"

在 Go 语言中，正弦函数由 math 包提供，函数入口为 math.Sin。正弦函数的参数为 float64，返回值也是 float64。在使用正弦函数时，根据实际精度可以进行转换。
Go 语言的标准库支持对图片像素进行访问，并且支持输出各种图片格式，如 JPEG、PNG、GIF 等。

一个布尔类型的值只有两种：true 和 false。if 和 for 语句的条件部分都是布尔类型的值，并且 == 和 < 等比较操作也会产生布尔型的值。
一元操作符 ! 对应逻辑非操作，因此 !true 的值为 false，更罗嗦的说法是 (!true==false) ==true，虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用 x 来表示 x==true。
Go语言对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface），它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。

布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：
s != "" && s[0] == 'x'
其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。

go语言字符串：
一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含可读的文本。字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。

UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。
字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。


Go 支持以下 2 种形式的字面值：
1) 解释字符串：
该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：
\n：换行符
\r：回车符
\t：tab 键
\u 或 \U：Unicode 字符
\\：反斜杠自身
2) 非解释字符串：
该类字符串使用反引号“`”括起来，支持换行，例如：
`This is a raw string \n` 中的 `\n\` 会被原样输出。

字符串拼接符“+”
两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。s2 追加在 s1 尾部并生成一个新的字符串 s。
go字符类型：

字符串中的每一个元素叫做“字符”。在遍历或者单个获取字符串元素时可以获得字符。严格来说，这并不是 Go语言的一个类型，字符只是整数的特殊用例。

Go语言的字符有以下两种：
一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。
另一种是 rune 类型，代表一个 UTF-8 字符。当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型实际是一个 int32。
byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。例如：var ch byte = 'A'；字符使用单引号括起来。
go数据类型的转换：
在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：
valueOfTypeB = typeB(valueOfTypeA)


















